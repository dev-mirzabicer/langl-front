.
  index.html
    -- File Content --
    <!DOCTYPE html>
    <html lang="en">
    <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>My Language Learner</title>
    </head>
    <body>
    <div id="root"></div>
    <!-- Vite injects scripts here -->
    <script type="module" src="src/main.tsx"></script>
    </body>
    </html>
    ---
  package.json
    -- File Content --
    {
    "name": "my-language-learner-frontend",
    "version": "1.0.0",
    "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
    },
    "dependencies": {
    "@headlessui/react": "^1.7.15",
    "@heroicons/react": "^2.0.18",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^7.1.1"
    },
    "devDependencies": {
    "@types/node": "^18.11.18",
    "@types/react": "^18.0.28",
    "@types/react-dom": "^18.0.11",
    "@vitejs/plugin-react": "^4.3.4",
    "autoprefixer": "^10.4.14",
    "postcss": "^8.4.21",
    "tailwindcss": "^3.2.7",
    "typescript": "^4.9.5",
    "vite": "^4.1.0"
    }
    }
    ---
  .eslintrc.js
    -- File Content --
    ---
  src
    App.tsx
      -- File Content --
      // src/App.tsx
      import React from "react";
      import { Routes, Route, Link } from "react-router-dom";
      import { ReaderContainer } from "./components/ReaderContainer";
      import { FlashcardPage } from "./components/FlashcardPage";
      
      export default function App() {
      return (
      <div className="min-h-screen flex flex-col bg-white">
      <header className="bg-blue-600 text-white p-4 shadow flex items-center">
      <h1 className="text-xl font-bold mr-4">My Language Learning App</h1>
      <Link to="/reader" className="mr-4 underline">
      Reader
      </Link>
      <Link to="/flashcards" className="underline">
      Flashcards
      </Link>
      </header>
      
      <main className="flex-1 p-4">
      <Routes>
      <Route path="/reader" element={<ReaderContainer />} />
      <Route path="/flashcards/*" element={<FlashcardPage />} />
      <Route path="/" element={<ReaderContainer />} />
      </Routes>
      </main>
      </div>
      );
      }
      ---
    main.tsx
      -- File Content --
      // src/main.tsx
      
      import React from "react";
      import ReactDOM from "react-dom/client";
      import { BrowserRouter } from "react-router-dom";
      import App from "./App";
      import "./index.css";
      
      ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
      <React.StrictMode>
      <BrowserRouter>
      <App />
      </BrowserRouter>
      </React.StrictMode>
      );
      ---
    types
      translation.ts
        -- File Content --
        export interface WordInfo {
        original_word: string;
        found_in_vocabulary: boolean;
        match_type: string;
        vocabulary_entry: {
        word: string;
        language: string;
        translation: string | null;
        state: number;
        due: string | null;
        stability: number;
        difficulty: number;
        last_review: string | null;
        step: number;
        } | null;
        }
        
        export interface SentenceData {
        original: string;
        translated: string;
        src_tokenized: string[];
        trg_tokenized: string[];
        alignment: Array<[number, number]>;
        wordInfo: WordInfo[];
        }
        
        export interface TranslationResponse {
        originalText: string;
        translatedText: string;
        alignment: Array<Array<[number, number]>> | Array<[number, number]>;
        sentences?: SentenceData[];
        }
        ---
    index.css
      -- File Content --
      @tailwind base;
      @tailwind components;
      @tailwind utilities;
      
      /* You can add global styles here as well. */
      ---
    components
      SentenceBlock.tsx
        -- File Content --
        import React, { useMemo } from "react";
        import { SentenceData, WordInfo } from "../types/translation";
        import { WordToken } from "./WordToken";
        
        // A set of distinct background colors from Tailwind for alignment highlighting
        const colorPalette = [
        "bg-red-200",
        "bg-blue-200",
        "bg-green-200",
        "bg-yellow-200",
        "bg-purple-200",
        "bg-pink-200",
        "bg-orange-200",
        "bg-amber-200",
        "bg-lime-200",
        "bg-cyan-200",
        "bg-indigo-200",
        "bg-fuchsia-200",
        // Add more if needed
        ];
        
        interface ColorizedToken {
        text: string;
        colorClass?: string;
        }
        
        // Takes the alignment array, source tokens, target tokens, and applies color classes
        function buildColorMaps(
        srcTokens: string[],
        trgTokens: string[],
        alignment: Array<[number, number]>
        ) {
        const sourceColorized: ColorizedToken[] = srcTokens.map((w) => ({ text: w }));
        const targetColorized: ColorizedToken[] = trgTokens.map((w) => ({ text: w }));
        
        let colorIndex = 0;
        for (const [srcIdx, trgIdx] of alignment) {
        if (srcIdx < 0 || srcIdx >= sourceColorized.length) continue;
        if (trgIdx < 0 || trgIdx >= targetColorized.length) continue;
        
        const srcHasColor = sourceColorized[srcIdx].colorClass;
        const trgHasColor = targetColorized[trgIdx].colorClass;
        
        // If both uncolored, pick a new color from the palette
        if (!srcHasColor && !trgHasColor) {
        const color = colorPalette[colorIndex % colorPalette.length];
        sourceColorized[srcIdx].colorClass = color;
        targetColorized[trgIdx].colorClass = color;
        colorIndex++;
        }
        // If only one side has color, apply the same color to the other side
        else if (srcHasColor && !trgHasColor) {
        targetColorized[trgIdx].colorClass = srcHasColor;
        } else if (!srcHasColor && trgHasColor) {
        sourceColorized[srcIdx].colorClass = trgHasColor;
        }
        // If both have color but differ, you might unify them, but itâ€™s rare in typical alignments.
        // We'll skip it here for clarity.
        }
        
        return { sourceColorized, targetColorized };
        }
        
        interface Props {
        sentence: SentenceData;
        showTranslation: boolean;
        showWordHints: boolean;
        }
        
        export function SentenceBlock({ sentence, showTranslation, showWordHints }: Props) {
        const { original, translated, src_tokenized, trg_tokenized, alignment, wordInfo } = sentence;
        
        // Build color-coded tokens for the source and target lines
        const { sourceColorized, targetColorized } = useMemo(() => {
        return buildColorMaps(src_tokenized, trg_tokenized, alignment);
        }, [src_tokenized, trg_tokenized, alignment]);
        
        // Render
        return (
        <div className="p-2 bg-gray-100 rounded">
        {/* SOURCE LINE (Swedish) */}
        <div className="flex flex-wrap gap-2">
        {sourceColorized.map((token, i) => {
        // We'll rely on wordInfo[i] to hold the FSRS data for token i
        const info: WordInfo | undefined = wordInfo[i];
        
        if (showWordHints && info) {
        // We show it as a WordToken with popover
        return (
        <WordToken
        key={i}
        info={info}
        colorClass={token.colorClass}
        />
        );
        } else {
        // If not showing popovers, just show the color-coded text
        return (
        <span
        key={i}
        className={`px-1 rounded ${token.colorClass || ""}`}
        >
        {token.text}
        </span>
        );
        }
        })}
        </div>
        
        {/* TARGET LINE (English), only shown if showTranslation = true */}
        {showTranslation && (
        <div className="mt-1 flex flex-wrap gap-2">
        {targetColorized.map((token, i) => (
        <span
        key={i}
        className={`px-1 rounded ${token.colorClass || ""}`}
        >
        {token.text}
        </span>
        ))}
        </div>
        )}
        </div>
        );
        }
        ---
      WordToken.tsx
        -- File Content --
        import React, { useState, useEffect } from "react";
        import { WordInfo } from "../types/translation";
        import { FSRSButtons } from "./FSRSButtons";
        import { SpeakerWaveIcon } from "@heroicons/react/24/outline";
        
        /**
        * A minimal shape for storing the FSRS data once we fetch it.
        * You might store more fields if needed.
        */
        interface FSRSData {
        word: string;
        language: string;
        translation: string | null;
        state: number;
        due: string | null;
        stability: number;
        difficulty: number;
        last_review: string | null;
        step: number;
        }
        
        interface Props {
        info: WordInfo;       // The initial info from translation
        colorClass?: string;  // Alignment highlight color
        }
        
        export function WordToken({ info, colorClass }: Props) {
        const [showPopover, setShowPopover] = useState(false);
        
        const {
        original_word,
        found_in_vocabulary,
        vocabulary_entry
        } = info;
        
        // We'll keep a piece of local FSRS state. Initially from WordInfo if known, else undefined.
        const [fsrsData, setFsrsData] = useState<FSRSData | null>(() => {
        if (found_in_vocabulary && vocabulary_entry) {
        return {
        word: vocabulary_entry.word,
        language: vocabulary_entry.language,
        translation: vocabulary_entry.translation,
        state: vocabulary_entry.state,
        due: vocabulary_entry.due,
        stability: vocabulary_entry.stability,
        difficulty: vocabulary_entry.difficulty,
        last_review: vocabulary_entry.last_review,
        step: vocabulary_entry.step
        };
        }
        return null;
        });
        
        const isKnown = fsrsData != null;
        
        // We'll store a dictionary translation from /api/dictionary/lookup
        const [dictTranslation, setDictTranslation] = useState<string>("");
        
        // On popover open, fetch single-word dictionary + also refresh FSRS data
        useEffect(() => {
        if (showPopover) {
        fetchDictionaryTranslation(original_word);
        refreshFSRSInfo(original_word, "sv");
        }
        }, [showPopover]);
        
        // Dictionary: from /api/dictionary/lookup
        const fetchDictionaryTranslation = async (word: string) => {
        try {
        const params = new URLSearchParams({ word, language: "sv" });
        const resp = await fetch(`http://127.0.0.1:5000/api/dictionary/lookup?${params}`);
        if (!resp.ok) {
        throw new Error(`Dictionary lookup failed: ${resp.statusText}`);
        }
        const data = await resp.json();
        if (data.translation) {
        setDictTranslation(data.translation);
        } else {
        setDictTranslation("(No dictionary translation found)");
        }
        } catch (err) {
        console.error(err);
        setDictTranslation("(Error fetching translation)");
        }
        };
        
        // FSRS: from /api/fsrs/vocabulary/lookup
        const refreshFSRSInfo = async (word: string, language: string) => {
        try {
        const params = new URLSearchParams({ word: word.toLowerCase(), language: language.toLowerCase() });
        const resp = await fetch(`http://127.0.0.1:5000/api/fsrs/vocabulary/lookup?${params}`);
        if (resp.ok) {
        const data = await resp.json();
        setFsrsData(data);  // update local FSRS data
        } else {
        // If 404 => means not in vocab
        setFsrsData(null);
        }
        } catch (err) {
        console.error(err);
        setFsrsData(null);
        }
        };
        
        // TTS for Swedish words
        const handleSpeak = () => {
        const utterance = new SpeechSynthesisUtterance(original_word);
        utterance.lang = "sv-SE";
        speechSynthesis.speak(utterance);
        };
        
        // Add word => let server fetch translation => then refresh FSRS data
        const handleAddWord = async () => {
        if (!original_word.trim()) return;
        try {
        const resp = await fetch("http://127.0.0.1:5000/api/fsrs/vocabulary/add", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
        word: original_word,
        language: "sv",
        translation: ""
        })
        });
        if (!resp.ok) {
        throw new Error(`Failed to add word: ${resp.statusText}`);
        }
        // Once added, refresh FSRS info
        refreshFSRSInfo(original_word, "sv");
        } catch (err) {
        console.error("Add word error:", err);
        }
        };
        
        return (
        <span className="relative">
        <span
        className={`
        cursor-pointer px-1 py-0.5 rounded
        ${colorClass || ""}
        ${isKnown ? "ring-1 ring-green-300" : "ring-1 ring-orange-300"}
        `}
        onClick={() => setShowPopover(!showPopover)}
        >
        {original_word}
        </span>
        
        {showPopover && (
        <div
        className="absolute top-full left-0 mt-1 z-50 bg-white border rounded shadow-lg p-3 w-64"
        onMouseLeave={() => setShowPopover(false)}
        >
        {/* Title row: word + TTS icon */}
        <div className="flex justify-between items-center mb-2">
        <div className="font-semibold">{original_word}</div>
        <button onClick={handleSpeak}>
        <SpeakerWaveIcon className="w-5 h-5 text-gray-600" />
        </button>
        </div>
        
        {/* Always show dictionary translation */}
        <p className="text-sm text-gray-800 mb-2">
        Dictionary: <strong>{dictTranslation}</strong>
        </p>
        
        {/* If known, show FSRS data + rating; else show "Add Word" */}
        {isKnown && fsrsData ? (
        <>
        <p className="text-sm text-gray-600 mb-2">
        FSRS stored translation:{" "}
        <strong>
        {fsrsData.translation || "(No FSRS translation stored)"}
        </strong>
        </p>
        <FSRSButtons
        word={fsrsData.word}
        language={fsrsData.language}
        onRatingSuccess={() => {
        // Refresh after rating
        refreshFSRSInfo(fsrsData.word, fsrsData.language);
        }}
        />
        </>
        ) : (
        <>
        <p className="text-sm text-red-500 mb-2">
        Not in your vocabulary yet.
        </p>
        <button
        className="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded"
        onClick={handleAddWord}
        >
        Add word
        </button>
        </>
        )}
        </div>
        )}
        </span>
        );
        }
        ---
      ReaderContainer.tsx
        -- File Content --
        // src/components/ReaderContainer.tsx
        import React, { useState } from "react";
        import { TranslationResponse } from "../types/translation";
        import { SentenceBlock } from "./SentenceBlock";
        
        const supportedLanguages = ["EN", "SV", "DE", "FR", "ES", "JA", "ZH"];
        
        export function ReaderContainer() {
        const [sourceText, setSourceText] = useState("");
        const [translationData, setTranslationData] = useState<TranslationResponse | null>(null);
        
        const [showTranslation, setShowTranslation] = useState(true);
        const [showWordHints, setShowWordHints] = useState(true);
        
        // NEW: user-selectable source/target languages
        const [sourceLanguage, setSourceLanguage] = useState("SV");  // default to Swedish
        const [targetLanguage, setTargetLanguage] = useState("EN");  // default to English
        
        const handleTranslate = async () => {
        if (!sourceText.trim()) return;
        
        try {
        const resp = await fetch("http://127.0.0.1:5000/api/translation", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
        text: sourceText,
        sourceLanguage: sourceLanguage.toUpperCase(),
        targetLanguage: targetLanguage.toUpperCase(),
        splitSentences: true,
        markWords: true
        })
        });
        if (!resp.ok) {
        throw new Error(`Translation request failed: ${resp.statusText}`);
        }
        const data: TranslationResponse = await resp.json();
        setTranslationData(data);
        } catch (err) {
        console.error("Error during translation:", err);
        }
        };
        
        return (
        <div className="space-y-4">
        {/* 1. Language selection row */}
        <div className="flex items-center space-x-4">
        <div>
        <label>Source: </label>
        <select
        value={sourceLanguage}
        onChange={(e) => setSourceLanguage(e.target.value)}
        className="border rounded px-2 py-1"
        >
        {supportedLanguages.map((lang) => (
        <option key={lang} value={lang}>
        {lang}
        </option>
        ))}
        </select>
        </div>
        
        <div>
        <label>Target: </label>
        <select
        value={targetLanguage}
        onChange={(e) => setTargetLanguage(e.target.value)}
        className="border rounded px-2 py-1"
        >
        {supportedLanguages.map((lang) => (
        <option key={lang} value={lang}>
        {lang}
        </option>
        ))}
        </select>
        </div>
        </div>
        
        {/* 2. Toggler row for show/hide translations/word hints */}
        <div className="flex items-center space-x-4">
        <label className="flex items-center space-x-2">
        <input
        type="checkbox"
        checked={showTranslation}
        onChange={() => setShowTranslation(!showTranslation)}
        />
        <span>Show Sentence Translation</span>
        </label>
        <label className="flex items-center space-x-2">
        <input
        type="checkbox"
        checked={showWordHints}
        onChange={() => setShowWordHints(!showWordHints)}
        />
        <span>Show Word Hints (Popovers)</span>
        </label>
        </div>
        
        {/* 3. Text input area */}
        <textarea
        className="w-full h-40 p-2 border rounded"
        placeholder={`Type or paste text in ${sourceLanguage} here...`}
        value={sourceText}
        onChange={(e) => setSourceText(e.target.value)}
        />
        
        <button
        onClick={handleTranslate}
        className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
        >
        Translate
        </button>
        
        {/* 4. Render results */}
        {translationData?.sentences && (
        <div className="mt-4 space-y-4">
        {translationData.sentences.map((sentence, idx) => (
        <SentenceBlock
        key={idx}
        sentence={sentence}
        showTranslation={showTranslation}
        showWordHints={showWordHints}
        />
        ))}
        </div>
        )}
        </div>
        );
        }
        ---
      FlashcardPage.tsx
        -- File Content --
        // src/components/FlashcardPage.tsx
        import React from "react";
        import { Routes, Route, Link } from "react-router-dom";
        import { FlashcardList } from "./FlashcardList";
        import { StudyCards } from "./StudyCards";
        
        export function FlashcardPage() {
        return (
        <div>
        {/* Nav for sub-pages */}
        <div className="mb-4 flex space-x-4">
        <Link to="list" className="underline text-blue-600">
        All Flashcards
        </Link>
        <Link to="study" className="underline text-blue-600">
        Study
        </Link>
        </div>
        
        <Routes>
        <Route path="list" element={<FlashcardList />} />
        <Route path="study" element={<StudyCards />} />
        {/* Default sub-route => list */}
        <Route path="*" element={<FlashcardList />} />
        </Routes>
        </div>
        );
        }
        ---
      FlashcardList.tsx
        -- File Content --
        // src/components/FlashcardList.tsx
        import React, { useEffect, useState } from "react";
        
        interface VocabEntry {
        word: string;
        language: string;
        translation: string | null;
        state: number;
        due: string | null;
        stability: number;
        difficulty: number;
        last_review: string | null;
        step: number;
        }
        
        const supportedLanguages = ["EN", "SV", "DE", "FR", "ES", "JA", "ZH"];
        
        export function FlashcardList() {
        const [allCards, setAllCards] = useState<VocabEntry[]>([]);
        const [filteredLanguage, setFilteredLanguage] = useState<string>("");
        
        useEffect(() => {
        // fetch all vocabulary
        fetchAllVocab();
        }, []);
        
        const fetchAllVocab = async () => {
        try {
        const resp = await fetch("http://127.0.0.1:5000/api/fsrs/vocabulary");
        if (!resp.ok) {
        throw new Error(`Failed to fetch vocabulary: ${resp.statusText}`);
        }
        const data = await resp.json();
        if (data.words) {
        setAllCards(data.words);
        }
        } catch (err) {
        console.error(err);
        }
        };
        
        // Filter by language if user picks one
        const displayed = filteredLanguage
        ? allCards.filter((c) => c.language.toLowerCase() === filteredLanguage.toLowerCase())
        : allCards;
        
        return (
        <div>
        <h2 className="text-xl font-semibold mb-2">All Flashcards</h2>
        <div className="mb-2">
        <label className="mr-2">Filter by Language:</label>
        <select
        value={filteredLanguage}
        onChange={(e) => setFilteredLanguage(e.target.value)}
        className="border rounded px-2 py-1"
        >
        <option value="">(All)</option>
        {supportedLanguages.map((lang) => (
        <option key={lang} value={lang}>
        {lang}
        </option>
        ))}
        </select>
        </div>
        
        <table className="min-w-full border border-gray-300">
        <thead>
        <tr className="bg-gray-200">
        <th className="border px-2 py-1">Word</th>
        <th className="border px-2 py-1">Language</th>
        <th className="border px-2 py-1">Translation</th>
        <th className="border px-2 py-1">State</th>
        <th className="border px-2 py-1">Due</th>
        <th className="border px-2 py-1">Stability</th>
        <th className="border px-2 py-1">Difficulty</th>
        </tr>
        </thead>
        <tbody>
        {displayed.map((card) => (
        <tr key={`${card.word}-${card.language}`}>
        <td className="border px-2 py-1">{card.word}</td>
        <td className="border px-2 py-1">{card.language}</td>
        <td className="border px-2 py-1">{card.translation || ""}</td>
        <td className="border px-2 py-1">{card.state}</td>
        <td className="border px-2 py-1">{card.due || ""}</td>
        <td className="border px-2 py-1">{card.stability?.toFixed(3)}</td>
        <td className="border px-2 py-1">{card.difficulty?.toFixed(3)}</td>
        </tr>
        ))}
        </tbody>
        </table>
        </div>
        );
        }
        ---
      FSRSButtons.tsx
        -- File Content --
        // FSRSButtons.tsx
        import React from "react";
        
        interface Props {
        word: string;
        language: string;
        onRatingSuccess?: () => void; // callback to refresh local data
        }
        
        export function FSRSButtons({ word, language, onRatingSuccess }: Props) {
        const handleRating = async (rating: string) => {
        try {
        // Send rating in lowercase
        const resp = await fetch("http://127.0.0.1:5000/api/fsrs/update", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
        word,
        language,
        response: rating.toLowerCase() // again|hard|good|easy
        })
        });
        if (!resp.ok) {
        const data = await resp.json();
        throw new Error(data.error || `FSRS update failed: ${resp.statusText}`);
        }
        console.log(`FSRS rating updated for word '${word}': ${rating}`);
        onRatingSuccess?.(); // refresh FSRS data
        } catch (err) {
        console.error(err);
        }
        };
        
        return (
        <div className="flex space-x-2">
        {["again", "hard", "good", "easy"].map((r) => (
        <button
        key={r}
        onClick={() => handleRating(r)}
        className="bg-gray-200 hover:bg-gray-300 text-sm px-2 py-1 rounded"
        >
        {r}
        </button>
        ))}
        </div>
        );
        }
        ---
      StudyCards.tsx
        -- File Content --
        // src/components/StudyCards.tsx
        import React, { useEffect, useState } from "react";
        
        interface DueWord {
        word: string;
        language: string;
        translation: string | null;
        }
        
        const supportedLanguages = ["EN", "SV", "DE", "FR", "ES", "JA", "ZH"];
        
        export function StudyCards() {
        const [dueWords, setDueWords] = useState<DueWord[]>([]);
        const [currentIndex, setCurrentIndex] = useState(0);
        const [showAnswer, setShowAnswer] = useState(false);
        const [selectedLanguage, setSelectedLanguage] = useState("");
        
        useEffect(() => {
        fetchDueWords();
        }, []);
        
        // 1. Fetch all due words
        const fetchDueWords = async () => {
        try {
        const resp = await fetch("http://127.0.0.1:5000/api/fsrs/review");
        if (!resp.ok) {
        throw new Error(`Failed to fetch due words: ${resp.statusText}`);
        }
        const data = await resp.json();
        if (data.words) {
        // data.words is an array of { word, language, translation }
        setDueWords(data.words);
        }
        } catch (err) {
        console.error(err);
        }
        };
        
        // 2. Filter by language if user picks
        const displayed = selectedLanguage
        ? dueWords.filter((w) => w.language.toLowerCase() === selectedLanguage.toLowerCase())
        : dueWords;
        
        // 3. The card being shown
        const card = displayed[currentIndex];
        
        const handleShowAnswer = () => {
        setShowAnswer(true);
        };
        
        // 4. On rating => call /api/fsrs/update => fetch new data or just move on
        const handleRating = async (rating: string) => {
        if (!card) return;
        
        try {
        const resp = await fetch("http://127.0.0.1:5000/api/fsrs/update", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
        word: card.word,
        language: card.language,
        response: rating
        })
        });
        if (!resp.ok) {
        const data = await resp.json();
        throw new Error(data.error || `FSRS update failed: ${resp.statusText}`);
        }
        console.log(`FSRS rating updated for word '${card.word}': ${rating}`);
        
        // Move to next card
        setShowAnswer(false);
        setCurrentIndex((prev) => prev + 1);
        } catch (err) {
        console.error(err);
        }
        };
        
        return (
        <div>
        <h2 className="text-xl font-semibold mb-2">Study (Due Cards)</h2>
        
        <div className="mb-2">
        <label className="mr-2">Filter by Language:</label>
        <select
        value={selectedLanguage}
        onChange={(e) => {
        setSelectedLanguage(e.target.value);
        setCurrentIndex(0);
        setShowAnswer(false);
        }}
        className="border rounded px-2 py-1"
        >
        <option value="">(All)</option>
        {supportedLanguages.map((lang) => (
        <option key={lang} value={lang}>
        {lang}
        </option>
        ))}
        </select>
        </div>
        
        {card ? (
        <div className="border p-4 rounded shadow w-80">
        <p className="text-lg font-bold mb-2">Word: {card.word}</p>
        {!showAnswer ? (
        <button
        onClick={handleShowAnswer}
        className="bg-blue-500 text-white py-1 px-3 rounded"
        >
        Show Answer
        </button>
        ) : (
        <>
        <p className="mb-4">Translation: {card.translation || "(no translation)"}</p>
        <div className="flex space-x-2">
        {["again", "hard", "good", "easy"].map((r) => (
        <button
        key={r}
        onClick={() => handleRating(r)}
        className="bg-gray-200 hover:bg-gray-300 text-sm px-2 py-1 rounded"
        >
        {r}
        </button>
        ))}
        </div>
        </>
        )}
        </div>
        ) : (
        <p>No due cards for this language.</p>
        )}
        </div>
        );
        }
        ---
